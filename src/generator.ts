import fs from "fs-extra";
import Handlebars from "handlebars";
import { register } from "hbs-dedent-helper";
import yaml from "js-yaml";
import { camelCase, isEmpty, last, memoize, upperFirst } from "lodash";
import path from "path/posix";
import { match } from "ts-pattern";
import {
  fieldMappings,
  GeneratedField,
  GeneratedFieldType,
  ImportedItem
} from "./field-mappings";
import { FileRemover } from "./file-remover";
import { GeneratorOpts, GeneratorOptsSchema, NamingOptions, NamingOptionsSchema } from "./generator-options";
import { doesMatchNameOrPattern, doesMatchNameOrPatternNamespaced } from "./matcher";
import { Logger } from "./logger"
import { Column, Table, TblsSchema } from "./tbls-types";

register();

type ColumnMethod =
  | "column"
  | "optionalColumn"
  | "columnWithDefaultValue"
  | "optionalColumnWithDefaultValue"
  | "computedColumn"
  | "optionalComputedColumn"
  | "primaryKey"
  | "autogeneratedPrimaryKey";

interface FieldTmplInput {
  name: string;
  isPK: boolean;
  columnMethod: ColumnMethod;
  columnName: string;
  isOptional: boolean;
  hasDefault: boolean;
  fieldType: GeneratedFieldType;
  includeDBTypeWhenIsOptional: boolean;
}

interface ImportTmplInput {
  importPath: string;
  imported: string[];
  isDefault: boolean;
}

interface RepoInput {
  className: string
  methods: Record<string, string>
}

/**
 * Generator class for programmatic codegen.
 *
 * Most common usage involves creating an instance and calling generate function:
 *
 * ```ts
 * const options = {
 *    schemaPath: './schema.yaml',
 *    connectionSourcePath: './connection-source.ts'
 * }
 * const generator = new Generator(options);
 * await generator.generate();
 * ```
 *
 * See [GeneratorOpts](../interfaces/GeneratorOpts.md) for configuration options.
 *
 * For advanced use-cases, you can extend this class.
 * This enables you to use custom templates, pre/post processing of generated code
 * and custom logic for table/column/field mapping.
 */
export class Generator {
  protected opts: GeneratorOpts;
  protected naming: NamingOptions;

  private writtenFiles = new Set<string>()
  public logger: Logger = console;

  constructor(opts: GeneratorOpts) {
    this.opts = GeneratorOptsSchema.parse(opts);
    this.naming = NamingOptionsSchema.parse(this.opts.naming || {});
  }

  protected getFieldMappings = memoize(() => {
    return (this.opts.fieldMappings ?? []).concat(fieldMappings);
  });

  protected getTemplatePath = memoize(() => {
    return path.join(__dirname, "template.ts.hbs");
  });

  protected getCompiledTemplate = memoize(async () => {
    const rawTemplate = await fs.readFile(this.getTemplatePath(), "utf8");
    return Handlebars.compile(rawTemplate);
  });

  async generate() {
    const rawSchema = await fs.readFile(
      path.resolve(this.opts.schemaPath),
      "utf8"
    );
    const schema = TblsSchema.parse(yaml.load(rawSchema));
    await Promise.all(
      schema.tables.map(async (table) => {
        if (this.shouldProcess(table)) {
          await this.generateTableMapper(table);
        }
      })
    );
    await new FileRemover(
      this.opts,
      this.writtenFiles,
      this.logger
    ).removeExtraneousFiles()
  }

  protected shouldProcess(table: Table) {
    const filter = this.opts.tables;
    if (
      filter?.include &&
      filter.include.findIndex((it) =>
        doesMatchNameOrPatternNamespaced(it, table.name)
      ) < 0
    ) {
      return false;
    }
    if (
      filter?.exclude &&
      filter.exclude.findIndex((it) =>
        doesMatchNameOrPatternNamespaced(it, table.name)
      ) >= 0
    ) {
      return false;
    }
    return true;
  }

  protected getTableKind(table: Table): TableKind | null {
    return match(table.type.toLowerCase())
      .with("base table", () => "Table" as const)
      .with("table", () => "Table" as const)
      .with("view", () => "View" as const)
      .otherwise(() => null);
  }

  protected async getTableTemplateInput(table: Table, tableKind: TableKind, filePath: string) {
    // Qualified table name with schema prefix
    const tableName = this.extractTableName(table.name);
    const pkCol = this.findPrimaryKey(table);
    const fields = this.getFieldsInput(table, pkCol);
    const dbConnectionSource = this.getConnectionSourceImportPath(filePath);
    const exportTableClass = this.opts.export?.tableClasses ?? true;
    const wrapperTypeImports: ImportTmplInput[] = [];
    const className = this.getTableMapperClassName(table.name, tableKind);
    const rowTypes = this.getRowTypeInputs(tableName, tableKind, className, wrapperTypeImports);
    const valuesTypes = this.getValuesTypeInputs(tableName, tableKind, className, wrapperTypeImports);
    const pkField = fields.find(it => it.isPK)
    const repo = this.getRepoInput(tableName, tableKind, pkField)
    const colMapping = this.getColMappingInput(tableName, !!repo)
    const colSetName = this.getColSetName(tableName, tableKind);
    const instName = this.getTableMapperInstName(tableName, tableKind)
    const idPrefix = this.getIdPrefix(table);
    const rowTypePrefix = this.getRowTypePrefix(tableName);

    const adapterImports = this.getAdapterImports(filePath, fields);
    const typeImports = this.getTypeImports(filePath, fields, !!repo);
    const utilImports = this.getUtilImports(colSetName, !!repo)

    return this.preProcessTemplateInput({
      table: {
        name: this.opts.tableMapping?.useQualifiedTableName
          ? table.name
          : tableName,
        kind: tableKind,
        comment: this.formatComment(table.comment),
        idPrefix,
      },
      imports: [
        ...utilImports,
        ...adapterImports,
        ...typeImports,
        ...wrapperTypeImports,
      ],
      dbConnectionSource,
      className,
      instName,
      fields,
      adapterImports,
      exportTableClass,
      rowTypes,
      valuesTypes,
      importExtraTypes: rowTypes || valuesTypes,
      rowTypePrefix,
      colSetName,
      colMapping,
      pkField,
      repo
    });
  }

  protected getFieldsInput(table: Table, pkCol: Column | null): FieldTmplInput[] {
    return table.columns
      .filter((col) => {
        return !this.isColumnOmitted(table.name, col);
      })
      .map((col) => this.getFieldInput(col, table, pkCol));
  }

  protected getFieldInput(col: Column, table: Table, pkCol: Column | null) {
    const isOptional = this.isColumnOptional(table.name, col);
    const hasDefault = this.doesColumnHaveDefault(table.name, col);
    const isComputed = this.isColumnComputed(table.name, col);
    let isPK = false;
    let columnMethod!: ColumnMethod;
    if (col === pkCol) {
      const isAutoGenerated =
        col.default ??
        this.opts.common?.primaryKey?.isAutoGenerated ??
        false;
      columnMethod = isAutoGenerated
        ? "autogeneratedPrimaryKey"
        : "primaryKey";
      isPK = true;
    } else if (isComputed) {
      if (isOptional) {
        columnMethod = "optionalComputedColumn";
      } else {
        columnMethod = "computedColumn";
      }
    } else if (!isOptional && !hasDefault) {
      columnMethod = "column";
    } else if (isOptional && !hasDefault) {
      columnMethod = "optionalColumn";
    } else if (isOptional && hasDefault) {
      columnMethod = "optionalColumnWithDefaultValue";
    } else if (!isOptional && hasDefault) {
      columnMethod = "columnWithDefaultValue";
    }
    return {
      name: this.getFieldNameForColumn(table.name, col),
      columnName: col.name,
      comment: this.formatComment(col.comment),
      isOptional,
      hasDefault,
      columnMethod,
      fieldType: this.getFieldType(table.name, col),
      includeDBTypeWhenIsOptional: this.opts.includeDBTypeWhenIsOptional || false,
      isPK,
    };
  }

  protected getRepoInput(tableName: string, tableKind: TableKind, pkField?: FieldTmplInput): RepoInput | null {
    if (!pkField) return null;
    if (!this.opts.export?.crudRepository) return null;
    const pkFSuffix = upperFirst(pkField.name);

    const methods: Record<string, string> = {};

    methods.select = `select`;
    methods.selectWhere = `selectWhere`;

    methods.findAll = `findAll`;
    methods.findOne = `findOneBy${pkFSuffix}`;
    methods.findMany = `findManyBy${pkFSuffix}`;

    if (tableKind === 'Table') {
      methods.insert = `select`;
      methods.insertOne = `insertOne`;
      methods.insertMany = `insertMany`;

      methods.update = `update`;
      methods.updateOne = `updateOneBy${pkFSuffix}`;
      methods.updateMany = `updateManyBy${pkFSuffix}`;

      methods.delete = 'delete';
      methods.deleteOne = `deleteOneBy${pkFSuffix}`;
      methods.deleteMany = `deleteManyBy${pkFSuffix}`;
    }
    return {
      className: this.getCrudRepoName(tableName),
      methods,
    }
  }

  protected async generateTableMapper(table: Table) {
    const tableKind = this.getTableKind(table);
    if (!tableKind) {
      this.logger.warn(
        `Unknown table type ${table.type} for table ${table.name}: SKIPPING`
      );
      return;
    }
    const filePath = this.getOutputFilePath(table, tableKind);
    const templateInput = await this.getTableTemplateInput(table, tableKind, filePath)
    const template = await this.getCompiledTemplate();
    const output = await this.postProcessOutput(template(templateInput), table);
    await fs.ensureDir(path.dirname(filePath));
    if (this.opts.dryRun) {
      this.logger.info(`Will populate ${filePath} with:`);
      this.logger.info(output);
      this.logger.info("---");
    } else {
      this.logger.info(`Writing ${filePath}`);
      this.writtenFiles.add(path.relative(this.opts.outputDirPath, filePath));
      await fs.writeFile(filePath, output);
    }
  }

  protected getIdPrefix(table: Table) {
    let idPrefix = this.opts.tableMapping?.idPrefix;
    if (!idPrefix && this.opts.tableMapping?.useQualifiedTableName) {
      idPrefix = table.name
        .split(".")
        .slice(0, -1)
        .map((it) => upperFirst(camelCase(it)))
        .join("");
    }
    return idPrefix;
  }

  protected formatComment(comment: string | null | undefined) {
    if (isEmpty(comment)) return null;
    return (
      "/**\n" +
      comment!
        .split("\n")
        .map((it) => ` * ${it}`)
        .join("\n") +
      "\n*/"
    );
  }

  protected getConnectionSourceImportPath(outputFilePath: string) {
    const relPath = path.relative(
      path.dirname(outputFilePath),
      path.resolve(this.opts.connectionSourcePath)
    );
    return path.join(
      path.dirname(relPath),
      path.basename(relPath)
    );
  }

  protected getAdapterImports(
    outputFilePath: string,
    fields: FieldTmplInput[]
  ): ImportTmplInput[] {
    const imports = new Map<string, Set<string>>();
    const defaultImports = new Map<string, Set<string>>();
    for (const field of fields) {
      const adapter = field.fieldType?.adapter;
      if (!adapter) continue;
      const importPath = this.getAdapterImportPath(adapter, outputFilePath);
      let adapterImports;
      const map = adapter.isDefault ? defaultImports : imports;
      adapterImports = map.get(importPath) ?? new Set<string>();
      map.set(importPath, adapterImports);
      adapterImports.add(adapter.name);
    }
    return this.accumulateImports(imports, defaultImports);
  }

  private accumulateImports(
    imports: Map<string, Set<string>>,
    defaultImports: Map<string, Set<string>>
  ) {
    const inputs: ImportTmplInput[] = [];
    for (const [entries, isDefault] of [
      [imports.entries(), false],
      [defaultImports.entries(), true],
    ] as const) {
      for (const [importPath, importedSet] of entries) {
        inputs.push({
          importPath,
          imported: [...importedSet],
          isDefault,
        });
      }
    }
    return inputs;
  }

  protected getTypeImports(
    outputFilePath: string,
    fields: FieldTmplInput[],
    generateRepo: boolean
  ): ImportTmplInput[] {
    const imports = new Map<string, Set<string>>();
    const defaultImports = new Map<string, Set<string>>();
    for (const field of fields) {
      const tsType = field.fieldType.tsType;
      if (!tsType) continue;
      const importPath = tsType.importPath;
      const name = tsType.name;
      if (!importPath || !name) {
        continue;
      }
      const nImportPath = this.getImportPathForOutputPath(
        outputFilePath,
        importPath,
        tsType
      );
      const map = tsType.isDefault ? defaultImports : imports;
      const typeImports = map.get(nImportPath) ?? new Set<string>();
      map.set(nImportPath, typeImports);
      typeImports.add(name);
    }
    const importList = this.accumulateImports(imports, defaultImports);
    if (generateRepo) {
      importList.push({
        importPath: "ts-sql-query/expressions/dynamicConditionUsingFilters",
        imported: ["DynamicCondition"],
        isDefault: false,
      })
    }
    return importList;
  }

  protected getUtilImports(colSetName: string | null, generateRepo: boolean) {
    const imports: ImportTmplInput[] = []
    if (colSetName || generateRepo) {
      imports.push({
        importPath: "ts-sql-query/extras/utils",
        imported: ["extractColumnsFrom"],
        isDefault: false
      })
    }
    return imports;
  }

  protected getImportPathForOutputPath(
    filePath: string,
    importPath: string,
    importedItem: ImportedItem
  ) {
    if (importedItem.isRelative === false) return importPath;
    const result: string = path.relative(
      path.dirname(filePath),
      path.resolve(importPath)
    );
    if (result.startsWith(".")) {
      return result;
    } else {
      return "./" + result;
    }
  }

  protected getAdapterImportPath(
    adapter: ImportedItem,
    outputFilePath: string
  ) {
    const relImportPath =
      adapter.importPath ?? this.opts.common?.typeAdapter?.importPath;
    if (!relImportPath) {
      throw new Error(
        `Unable to resolve import path for type adapter: ${JSON.stringify(
          adapter
        )}`
      );
    }
    return this.getImportPathForOutputPath(
      outputFilePath,
      relImportPath,
      adapter
    );
  }

  protected async preProcessTemplateInput(input: any) {
    return input;
  }

  protected async postProcessOutput(output: string, _table: Table) {
    const sections = [output];
    if (this.opts.rawContent?.before) {
      sections.unshift(this.opts.rawContent.before)
    }
    if (this.opts.rawContent?.after) {
      sections.push(this.opts.rawContent.after)
    }
    return sections.join('\n');
  }

  protected getCrudRepoName(tableName: string) {
    return this.naming.crudRepositoryClassNamePrefix +
      this.getPascalCasedTableName(tableName) +
      this.naming.crudRepositoryClassNameSuffix;
  }

  protected getTableMapperClassName(tableName: string, tableKind: TableKind) {
    if (tableKind === 'Table') {
      return this.naming.tableClassNamePrefix +
        this.getPascalCasedTableName(tableName) +
        this.naming.tableClassNameSuffix;
    } else {
      return this.naming.viewClassNamePrefix +
        this.getPascalCasedTableName(tableName) +
        this.naming.viewClassNameSuffix;
    }
  }

  protected getRowTypePrefix(tableName: string) {
    return this.getPascalCasedTableName(tableName);
  }

  protected getTableMapperInstanceName(tableName: string, tableKind: TableKind) {
    if (tableKind === 'Table') {
      return this.naming.tableInstanceNamePrefix +
        this.getPascalCasedTableName(tableName) +
        this.naming.tableInstanceNameSuffix;
    } else {
      return this.naming.viewInstanceNamePrefix +
        this.getPascalCasedTableName(tableName) +
        this.naming.viewInstanceNameSuffix;
    }
  }

  protected getColumnsObjectName(tableName: string, tableKind: TableKind) {
    if (tableKind === 'Table') {
      if (this.naming.tableColumnsNamePrefix) {
        return this.naming.tableColumnsNamePrefix +
          this.getPascalCasedTableName(tableName) +
          this.naming.tableColumnsNameSuffix;
      } else {
        return this.getCamelCasedTableName(tableName) +
          this.naming.tableColumnsNameSuffix;
      }
    } else {
      if (this.naming.viewColumnsNamePrefix) {
        return this.naming.viewColumnsNamePrefix +
          this.getPascalCasedTableName(tableName) +
          this.naming.viewColumnsNameSuffix;
      } else {
        return this.getCamelCasedTableName(tableName) +
          this.naming.viewColumnsNameSuffix;
      }
    }
  }

  private getPascalCasedTableName(tableName: string) {
    return upperFirst(camelCase(last(tableName.split("."))));
  }

  private getCamelCasedTableName(tableName: string) {
    return camelCase(last(tableName.split(".")));
  }

  protected isColumnOmitted(tableName: string, col: Column) {
    const mapping = this.getFieldMappings().find(
      (it) =>
        it.generatedField === false &&
        doesMatchNameOrPatternNamespaced(it.columnName, col.name) &&
        doesMatchNameOrPatternNamespaced(it.tableName, tableName) &&
        doesMatchNameOrPatternNamespaced(it.columnType, col.type)
    );
    return !!mapping;
  }

  protected isColumnOptional(tableName: string, col: Column): boolean {
    const mapping = this.getFieldMappings().find(
      (it) =>
        it.generatedField &&
        it.generatedField.isOptional != null &&
        doesMatchNameOrPatternNamespaced(it.columnName, col.name) &&
        doesMatchNameOrPatternNamespaced(it.tableName, tableName) &&
        doesMatchNameOrPatternNamespaced(it.columnType, col.type)
    );
    if (mapping?.generatedField) {
      return mapping.generatedField.isOptional === true;
    } else {
      return col.nullable === true;
    }
  }

  protected doesColumnHaveDefault(tableName: string, col: Column): boolean {
    const mapping = this.getFieldMappings().find(
      (it) =>
        it.generatedField &&
        it.generatedField.hasDefault != null &&
        doesMatchNameOrPatternNamespaced(it.columnName, col.name) &&
        doesMatchNameOrPatternNamespaced(it.tableName, tableName) &&
        doesMatchNameOrPatternNamespaced(it.columnType, col.type)
    );
    if (mapping?.generatedField) {
      return mapping.generatedField.hasDefault === true;
    } else {
      return col.default != null;
    }
  }

  protected isColumnComputed(tableName: string, col: Column): boolean {
    const mapping = this.getFieldMappings().find(
      (it) =>
        it.generatedField &&
        it.generatedField.isComputed != null &&
        doesMatchNameOrPatternNamespaced(it.columnName, col.name) &&
        doesMatchNameOrPatternNamespaced(it.tableName, tableName) &&
        doesMatchNameOrPatternNamespaced(it.columnType, col.type)
    );
    if (mapping?.generatedField) {
      return mapping.generatedField.isComputed === true;
    }
    return false;
  }

  protected getFieldNameForColumn(tableName: string, col: Column) {
    const mapping = this.getFieldMappings().find(
      (it) =>
        it.generatedField &&
        it.generatedField?.name &&
        doesMatchNameOrPatternNamespaced(it.columnName, col.name) &&
        doesMatchNameOrPatternNamespaced(it.tableName, tableName) &&
        doesMatchNameOrPatternNamespaced(it.columnType, col.type)
    );
    return (
      (mapping?.generatedField as GeneratedField)?.name ?? camelCase(col.name)
    );
  }

  protected getFieldType(tableName: string, col: Column): GeneratedFieldType {
    const mapping = this.getFieldMappings().find(
      (it) =>
        it.generatedField &&
        it.generatedField?.type &&
        doesMatchNameOrPatternNamespaced(it.columnName, col.name) &&
        doesMatchNameOrPatternNamespaced(it.tableName, tableName) &&
        doesMatchNameOrPatternNamespaced(it.columnType, col.type)
    );
    if (!mapping) {
      throw new Error(
        `Failed to infer field type for ${tableName}.${col.name}`
      );
    }
    const generatedField = mapping.generatedField as GeneratedField;
    const dbTypeName = generatedField.type?.dbType?.name ?? col.type;
    let tsTypeName = generatedField.type?.tsType?.name;
    if (generatedField?.type?.adapter && !tsTypeName) {
      tsTypeName = upperFirst(camelCase(dbTypeName));
    }
    return {
      ...generatedField.type,
      dbType: {
        ...generatedField.type?.dbType,
        name: dbTypeName,
      },
      tsType: {
        ...generatedField.type?.tsType,
        name: tsTypeName ?? "unknown",
      },
    };
  }

  protected getOutputFilePath(table: Table, tableKind: TableKind) {
    const fileName = this.getOutputFileName(table, tableKind);
    return path.join(this.opts.outputDirPath, fileName);
  }

  protected getOutputFileName(table: Table, tableKind: TableKind) {
    return this.getTableMapperClassName(table.name, tableKind) + ".ts";
  }

  protected findPrimaryKey(table: Table) {
    let col: Column | null = null;
    const commonPKColName = this.opts.common?.primaryKey?.name;
    if (commonPKColName) {
      col = table.columns.find((it) => it.name === commonPKColName) ?? null;
    }
    if (!col) {
      const pkConstraint = table.constraints.find(
        (it) => it.type === "PRIMARY KEY"
      );
      if (pkConstraint && pkConstraint.columns.length === 1) {
        return table.columns.find((it) => it.name === pkConstraint.columns[0]) ?? null;
      }
    }
    return null;
  }

  protected wrapType(typeExpr: string, wrapper?: string | null) {
    if (!wrapper) return typeExpr;
    return `${wrapper}<${typeExpr}>`;
  }

  protected getTypeWrapper(typeName: string) {
    return this.opts.typeWrappers
      ?.find(it => {
        return doesMatchNameOrPattern(it.typeName, typeName)
      })
      ?.wrapper
  }

  protected extractTableName(configTableName: string) {
    return last(configTableName.split(".")) as string;
  }

  protected getSelectedRowTypeName(tableName: string) {
    return this.naming.selectedRowTypeNamePrefix +
      this.getPascalCasedTableName(tableName) +
      this.naming.selectedRowTypeNameSuffix;
  }

  protected getInsertableRowTypeName(tableName: string) {
    return this.naming.insertableRowTypeNamePrefix +
      this.getPascalCasedTableName(tableName) +
      this.naming.insertableRowTypeNameSuffix;
  }

  protected getUpdatableRowTypeName(tableName: string) {
    return this.naming.updatableRowTypeNamePrefix +
      this.getPascalCasedTableName(tableName) +
      this.naming.updatableRowTypeNameSuffix;
  }

  protected getSelectedValuesTypeName(tableName: string) {
    return this.naming.selectedValuesTypeNamePrefix +
      this.getPascalCasedTableName(tableName) +
      this.naming.selectedValuesTypeNameSuffix;
  }

  protected getInsertableValuesTypeName(tableName: string) {
    return this.naming.insertableValuesTypeNamePrefix +
      this.getPascalCasedTableName(tableName) +
      this.naming.insertableValuesTypeNameSuffix;
  }

  protected getUpdatableValuesTypeName(tableName: string) {
    return this.naming.updatableValuesTypeNamePrefix +
      this.getPascalCasedTableName(tableName) +
      this.naming.updatableValuesTypeNameSuffix;
  }

  protected getColMappingObjName(tableName: string) {
    return this.getPascalCasedTableName(tableName) + this.naming.columnTypeMappingInterfaceNameSuffix;
  }

  protected getWrappedTypeInput(name: string, baseExpr: string, imports: ImportTmplInput[]) {
    const selectedWrapper = this.getTypeWrapper(name)
    if (selectedWrapper?.importPath)
      imports.push({
        importPath: selectedWrapper.importPath,
        imported: [selectedWrapper.name],
        isDefault: !!selectedWrapper.isDefault
      });
    return {
      name,
      expr: this.wrapType(
        baseExpr,
        selectedWrapper?.name
      )
    };
  }

  protected getRowTypeInputs(
    tableName: string,
    tableKind: TableKind,
    mapperClassName: string,
    imports: ImportTmplInput[]
  ) {
    const rowTypes = this.opts.export?.rowTypes
      ? ({} as any)
      : false;
    if (rowTypes !== false) {
      rowTypes.selected = this.getWrappedTypeInput(
        this.getSelectedRowTypeName(tableName),
        `SelectedRow<${mapperClassName}>`,
        imports
      );
      if (tableKind !== "View") {
        rowTypes.insertable = this.getWrappedTypeInput(
          this.getInsertableRowTypeName(tableName),
          `InsertableRow<${mapperClassName}>`,
          imports
        );
        rowTypes.updatable = this.getWrappedTypeInput(
          this.getUpdatableRowTypeName(tableName),
          `UpdatableRow<${mapperClassName}>`,
          imports
        );
      }
    }
    return rowTypes
  }

  protected getValuesTypeInputs(
    tableName: string,
    tableKind: TableKind,
    mapperClassName: string,
    imports: ImportTmplInput[]
  ) {
    const valuesTypes = this.opts.export?.valuesTypes ? ({} as any) : false;
    if (valuesTypes !== false) {
      valuesTypes.selected = this.getWrappedTypeInput(
        this.getSelectedValuesTypeName(tableName),
        `SelectedValues<${mapperClassName}>`,
        imports
      );
      if (tableKind !== "View") {
        valuesTypes.insertable = this.getWrappedTypeInput(
          this.getInsertableValuesTypeName(tableName),
          `InsertableValues<${mapperClassName}>`,
          imports
        )
        valuesTypes.updatable = this.getWrappedTypeInput(
          this.getUpdatableValuesTypeName(tableName),
          `UpdatableValues<${mapperClassName}>`,
          imports
        );
      }
    }
    return valuesTypes;
  }

  protected getColSetName(tableName: string, tableKind: TableKind) {
    return this.opts.export?.extractedColumns
      ? this.getColumnsObjectName(tableName, tableKind)
      : null;
  }

  protected getTableMapperInstName(tableName: string, tableKind: TableKind) {
    return this.opts.export?.tableInstances || this.opts.export?.extractedColumns
      ? this.getTableMapperInstanceName(tableName, tableKind)
      : null;
  }

  protected getColMappingInput(tableName: string, didGenerateRepo: boolean) {
    const exportColMapping = (this.opts.export?.columnTypeMappingInterface || didGenerateRepo)
      ? ({} as any)
      : false;
    if (exportColMapping !== false) {
      exportColMapping.name = this.getColMappingObjName(tableName)
    }
    return exportColMapping
  }
}


type TableKind = "Table" | "View"
