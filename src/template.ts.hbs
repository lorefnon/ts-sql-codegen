{{#trim-trailing-whitespace}}
/**
 * DO NOT EDIT:
 *
 * This file has been auto-generated from database schema using ts-sql-codegen.
 * Any changes will be overwritten.
 */
import { {{table.kind}} } from "ts-sql-query/{{table.kind}}";
import type { DBConnection } from "{{dbConnectionSource}}";
{{#if importExtraTypes}}
import {
    {{#if rowTypes.insertable}}
    InsertableRow,
    {{/if}}
    {{#if rowTypes.updatable}}
    UpdatableRow,
    {{/if}}
    {{#if rowTypes.selected}}
    SelectedRow,
    {{else if repo}}
    SelectedRow,
    {{/if}}
    {{#if valuesTypes.insertable}}
    InsertableValues,
    {{/if}}
    {{#if valuesTypes.updatable}}
    UpdatableValues,
    {{/if}}
    {{#if valuesTypes.selected}}
    SelectedValues,
    {{/if}}
} from "ts-sql-query/extras/types";
{{/if}}
{{#each imports}}
    {{#if isDefault}}
        {{#each imported}}
            {{#dedent-by 4 "level"}}
                import {{.}} from "{{../importPath}}";
            {{/dedent-by}}
        {{/each}}
    {{else}}
        {{#dedent-by 3 "level"}}
            import {
                {{#dedent-by 2 "level"}}
                    {{#each imported}}
                        {{.}},
                    {{/each}}
                {{/dedent-by}}
            } from "{{importPath}}";
        {{/dedent-by}}
    {{/if}}
{{/each}}

{{#if table.comment}}
{{table.comment}}
{{/if}}
{{#if exportTableClass}}export {{/if}}class {{className}} extends {{table.kind}}<DBConnection, '{{table.idPrefix}}{{className}}'> {
    {{#dedent-by 3 "level"}}
        {{#each fields}}
            {{#if field.comment}}
            {{field.comment}}
            {{/if}}
            {{#if fieldType.kind}}
                {{#if includeDBTypeWhenIsOptional}}
                {{name}} = this.{{columnMethod}}<{{fieldType.tsType.name}}, '{{fieldType.dbType.name}}'>('{{columnName}}', '{{fieldType.kind}}', '{{fieldType.dbType.name}}'{{#if fieldType.adapter}}, {{fieldType.adapter.name}}{{/if}});
                {{else}}
                {{name}} = this.{{columnMethod}}<{{fieldType.tsType.name}}>('{{columnName}}', '{{fieldType.kind}}', '{{fieldType.dbType.name}}'{{#if fieldType.adapter}}, {{fieldType.adapter.name}}{{/if}});
                {{/if}}
            {{else}}
                {{name}} = this.{{columnMethod}}('{{columnName}}', '{{fieldType.dbType.name}}'{{#if fieldType.adapter}}, {{fieldType.adapter.name}}{{/if}});
            {{/if}}
        {{/each}}
    {{/dedent-by}}

    constructor() {
        super('{{table.name}}');
    }
}
{{#if colMapping}}

export type {{colMapping.name}} = {
    {{#each fields}}
    {{#if fieldType.kind}}
    {{name}}: ['{{fieldType.kind}}', {{fieldType.tsType.name}}]
    {{else}}
    {{name}}: '{{fieldType.dbType.name}}'
    {{/if}}
    {{/each}}
}
{{/if}}

{{#if instName}}
export const {{instName}} = new {{className}}();
{{/if}}

{{#each rowTypes}}
export type {{name}} = {{{expr}}};
{{/each}}
{{#each valuesTypes}}
export type {{name}} = {{{expr}}};
{{/each}}
{{#if colSetName}}
export const {{colSetName}} = extractColumnsFrom({{instName}});
{{/if}}
{{/trim-trailing-whitespace}}
{{#if repo}}
export type {{className}}Pk = SelectedRow<{{className}}>["{{pkField.name}}"];

{{#each repo.class.decorators}}
{{expr}}
{{/each}}
export class {{repo.class.name}} {
    constructor(
        public getConnection: () => DBConnection,
        public table: {{className}}{{#if instName}} = {{instName}}{{/if}},
    ) {}

    tableCols = {{#if colSetName}}{{colSetName}}{{else}}extractColumnsFrom(this.table){{/if}};
    {{#if repo.methods.select}}

    {{#each repo.methods.select.decorators}}
    {{expr}}
    {{/each}}
    {{repo.methods.select.name}}(conn = this.getConnection()) {
        return conn.selectFrom(this.table);
    }
    {{/if}}
    {{#if repo.methods.selectWhere}}

    {{#each repo.methods.selectWhere.decorators}}
    {{expr}}
    {{/each}}
    {{repo.methods.selectWhere.name}}(cond: DynamicCondition<{{colMapping.name}}>, conn = this.getConnection()) {
        return this.{{repo.methods.select.name}}(conn)
            .where(conn.dynamicConditionFor(this.tableCols).withValues(cond))
            .select(this.tableCols)
            .executeSelectMany();
    }
    {{/if}}
    {{#if repo.methods.findAll}}

    {{#each repo.methods.findAll.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.findAll.name}}(conn = this.getConnection()) {
        const rows = await this.{{repo.methods.select.name}}(conn)
            .select(this.tableCols)
            .executeSelectMany();
        {{#if repo.transformers.outgoingSelectedRow}}
        return rows.map({{repo.transformers.outgoingSelectRow.name}});
        {{else}}
        return rows;
        {{/if}}
    }
    {{/if}}
    {{#if repo.methods.findOne}}

    {{#each repo.methods.findOne.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.findOne.name}}({{pkField.name}}: {{repo.incomingId.type.name}}, conn = this.getConnection()) {
        const row = await this.{{repo.methods.select.name}}(conn)
            .where(this.table.{{pkField.name}}.equals(
                {{#if repo.transformers.incomingId}}{{repo.transformers.incomingId.name}}({{pkField.name}})
                {{else}}{{pkField.name}}
                {{/if}}
            ))
            .select(this.tableCols)
            .executeSelectNoneOrOne();
        {{#if repo.transformers.outgoingSelectedRow}}
        if (row) return {{repo.transformers.outgoingSelectedRow.name}}(row)
        {{/if}}
        return row
    }
    {{/if}}
    {{#if repo.methods.findMany}}

    {{#each repo.methods.findMany.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.findMany.name}}({{pkField.name}}List: {{repo.incomingId.type.name}}[], conn = this.getConnection()) {
        const rows = await this.{{repo.methods.select.name}}(conn)
            .where(this.table.{{pkField.name}}.in(
                {{#if repo.transformers.incomingId}}{{pkField.name}}List.map({{repo.transformers.incomingId.name}})
                {{else}}{{pkField.name}}List
                {{/if}}
            ))
            .select(this.tableCols)
            .executeSelectMany();
        {{#if repo.transformers.outgoingSelectedRow}}
        return rows.map({{repo.transformers.outgoingSelectRow.name}});
        {{else}}
        return rows;
        {{/if}}
    }
    {{/if}}
    {{#if repo.methods.insert}}

    {{#each repo.methods.insert.decorators}}
    {{expr}}
    {{/each}}
    {{repo.methods.insert.name}}(conn = this.getConnection()) {
        return conn.insertInto(this.table);
    }
    {{/if}}
    {{#if repo.methods.insertOne}}

    {{#each repo.methods.insertOne.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.insertOne.name}}(row: InsertableRow<{{className}}>, conn = this.getConnection()) {
        const result = await this.{{repo.methods.insert.name}}(conn)
            .set(row)
            {{#if repo.mutationOutput.returnInserted}}
            .returning(this.tableCols)
            .executeInsertOne();
            {{else}}
            .executeInesrt();
            {{/if}}
        {{#if repo.mutationOutput.returnInserted}}
        {{#if repo.transformers.outgoingSelectedRow}}
        if (result) return {{repo.transformers.outgoingSelectedRow.name}}(result);
        {{/if}}
        {{/if}}
        return result;
    }
    {{/if}}
    {{#if repo.methods.insertMany}}

    {{#each repo.methods.insertMany.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.insertMany.name}}(rows: InsertableRow<{{className}}>[], conn = this.getConnection()) {
        const result = await this.{{repo.methods.insert.name}}(conn)
            .values(rows)
            {{#if repo.mutationOutput.returnInserted}}
            .returning(this.tableCols)
            .executeInsertMany();
            {{else}}
            .executeInsert();
            {{/if}}
        {{#if repo.mutationOutput.returnInserted}}
        {{#if repo.transformers.outgoingSelectedRow}}
        return result.map({{repo.transformers.outgoingSelectRow.name}});
        {{else}}
        return result;
        {{/if}}
        {{else}}
        return result;
        {{/if}}
    }
    {{/if}}
    {{#if repo.methods.update}}

    {{#each repo.methods.update.decorators}}
    {{expr}}
    {{/each}}
    {{repo.methods.update.name}}(conn = this.getConnection()) {
        return conn.update(this.table);
    }
    {{/if}}
    {{#if repo.methods.updateOne}}

    {{#each repo.methods.updateOne.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.updateOne.name}}({{pkField.name}}: {{className}}Pk, update: UpdatableRow<{{className}}>, conn = this.getConnection()) {
        const result = await this.{{repo.methods.update.name}}(conn)
            .set(update)
            .where(this.table.{{pkField.name}}.equals({{pkField.name}}))
            {{#if repo.mutationOutput.returnUpdated}}
            .returning(this.tableCols)
            .executeUpdateOne();
            {{else}}
            .executeUpdate();
            {{/if}}
        {{#if repo.mutationOutput.returnUpdated}}
        {{#if repo.transformers.outgoingSelectedRow}}
        if (result) return {{repo.transformers.outgoingSelectedRow.name}}(result)
        {{/if}}
        {{/if}}
        return result;
    }
    {{/if}}
    {{#if repo.methods.updateMany}}

    {{#each repo.methods.updateMany.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.updateMany.name}}({{pkField.name}}List: {{className}}Pk[], update: UpdatableRow<{{className}}>, conn = this.getConnection()) {
        const result = await this.{{repo.methods.update.name}}(conn)
            .set(update)
            .where(this.table.{{pkField.name}}.in({{pkField.name}}List))
            {{#if repo.mutationOutput.returnUpdated}}
            .returning(this.tableCols)
            .executeUpdateMany();
            {{else}}
            .executeUpdate();
            {{/if}}
        {{#if repo.mutationOutput.returnUpdated}}
        {{#if repo.transformers.outgoingSelectedRow}}
        return result.map({{repo.transformers.outgoingSelectRow.name}});
        {{else}}
        return result;
        {{/if}}
        {{else}}
        return result;
        {{/if}}
    }
    {{/if}}
    {{#if repo.methods.delete}}

    {{#each repo.methods.delete.decorators}}
    {{expr}}
    {{/each}}
    {{repo.methods.delete.name}}(conn = this.getConnection()) {
        return conn.deleteFrom(this.table);
    }
    {{/if}}
    {{#if repo.methods.deleteOne}}

    {{#each repo.methods.deleteOne.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.deleteOne.name}}({{pkField.name}}: {{className}}Pk, conn = this.getConnection()) {
        const result = await this.{{repo.methods.delete.name}}(conn)
            .where(this.table.{{pkField.name}}.equals({{pkField.name}}))
            {{#if repo.mutationOutput.returnDeleted}}
            .returning(this.tableCols)
            .executeDeleteOne();
            {{else}}
            .executeDelete();
            {{/if}}
        {{#if repo.mutationOutput.returnDeleted}}
        {{#if repo.transformers.outgoingSelectedRow}}
        if (result) return {{repo.transformers.outgoingSelectedRow.name}}(result)
        {{/if}}
        {{/if}}
        return result
    }
    {{/if}}
    {{#if repo.methods.deleteMany}}

    {{#each repo.methods.deleteMany.decorators}}
    {{expr}}
    {{/each}}
    async {{repo.methods.deleteMany.name}}({{pkField.name}}List: {{className}}Pk[], conn = this.getConnection()) {
        const result = await this.{{repo.methods.delete.name}}(conn)
            .where(this.table.{{pkField.name}}.in({{pkField.name}}List))
            {{#if repo.mutationOutput.returnDeleted}}
            .returning(this.tableCols)
            .executeDeleteMany();
            {{else}}
            .executeDelete();
            {{/if}}
        {{#if repo.mutationOutput.returnDeleted}}
        {{#if repo.transformers.outgoingSelectedRow}}
        return result.map({{repo.transformers.outgoingSelectRow.name}});
        {{else}}
        return result;
        {{/if}}
        {{else}}
        return result;
        {{/if}}
    }
    {{/if}}
}
{{/if}}
